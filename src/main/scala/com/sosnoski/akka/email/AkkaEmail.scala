package com.sosnoski.akka.email

import akka.actor._
import akka.routing.RoundRobinRouter
import akka.event.LoggingReceive

sealed trait EmailFlowMessage
/** @param count the total number of emails to generate */
case class Start(count: Int) extends EmailFlowMessage
/** @param count the number of emails to be generated by the receiving retrieval actor. */
case class Retrieve(count: Int) extends EmailFlowMessage
case class Build(name: String, email: String) extends EmailFlowMessage
case class Send(name: String, text: String, email: String) extends EmailFlowMessage
case class Update(name: String) extends EmailFlowMessage
object Complete extends EmailFlowMessage

// Runner1 is a minimal demonstration, with a single child actor of each type
object Runner1 extends App {

  // create an akka system
  val system = ActorSystem("EmailSystem")

  // run a minimal test, creating the root actor with a single child of each type and generating only 4 messages
  system.actorOf(Props(new EmailFlow(1, 1, 1, 1)), name = "EmailFlow1") ! new Start(6)
}

// Runner2 generates a lot more messages, with multiple child actors of each type
object Runner2 extends App {

  // create an akka system
  val system = ActorSystem("EmailSystem")
  
  // run a more substantial test, with multiple actors of each type and 40 total messages
  system.actorOf(Props(new EmailFlow(2, 3, 5, 2)), name = "EmailFlow2") ! new Start(40)
}

/**
 * Top-level actor for email generation simulation. The child actors are chained together to emulate the steps involved
 * in building and sending a list of emails.
 *
 * @param rCount number of retrieval actors
 * @param bCount number of builder actors
 * @param sCount number of sender actors
 * @param uCount number of update actors
 */
class EmailFlow(rCount: Int, bCount: Int, sCount: Int, uCount: Int) extends Actor {

  // configure the routers, passing each child actor (except last, which connects to this) a target router
  println("EmailFlow self.path " + self.path)
  // relative paths appear to sometimes work and sometimes not when run directly in sbt, but generally fail in Eclipse
  //  note that each actor (except this one) has a router as the direct parent and this actor as the grandparent
/*  val rProps = Props(new RetrieveData("../../builderRouter")).withRouter(RoundRobinRouter(rCount))
  val retrieveRouter = context.actorOf(rProps, name = "retrieveRouter")
  val bProps = Props(new EmailBuilder("../../senderRouter")).withRouter(RoundRobinRouter(bCount))
  val buildRouter = context.actorOf(bProps, name = "builderRouter")
  val sProps = Props(new SmtpSender("../../updaterRouter")).withRouter(RoundRobinRouter(sCount))
  val senderRouter = context.actorOf(sProps, name = "senderRouter")
  val uProps =  Props(new DatabaseUpdater("../..")).withRouter(RoundRobinRouter(uCount))
  val updateRouter = context.actorOf(uProps, name = "updaterRouter")    */
  // absolute paths appear to work more consistently
  val rProps = Props(new RetrieveData(self.path + "/builderRouter")).withRouter(RoundRobinRouter(rCount))
  val retrieveRouter = context.actorOf(rProps, name = "retrieveRouter")
  val bProps = Props(new EmailBuilder(self.path + "/senderRouter")).withRouter(RoundRobinRouter(bCount))
  val buildRouter = context.actorOf(bProps, name = "builderRouter")
  val sProps = Props(new SmtpSender(self.path + "/updaterRouter")).withRouter(RoundRobinRouter(sCount))
  val senderRouter = context.actorOf(sProps, name = "senderRouter")
  val uProps =  Props(new DatabaseUpdater(self.path.toString())).withRouter(RoundRobinRouter(uCount))
  val updateRouter = context.actorOf(uProps, name = "updaterRouter")
  
  // keep count of how many emails are requested and how many have been done
  var numDone = 0
  var countExpected = 0
  def receive = {
    case Start(count) =>
      countExpected = count
      val countPerRouter = count / rCount
      for (_ <- 2 to rCount) retrieveRouter ! Retrieve(countPerRouter)
      retrieveRouter ! Retrieve(count - countPerRouter*(rCount-1))
    case Complete =>
      numDone = numDone + 1
      println("Completed " + numDone)
      if (numDone >= countExpected) {
        
        // all emails done, so stop this actor and all child actors
        //  note that in a real system you'd just keep this actor around for reuse, unless you wanted to reconfigure the
        //  routing each time you generated a batch of emails
        context.stop(self)
        
        // shutdown system to kill off all threads
        //  this is to shutdown all akka threads so the code will exit once we're done
        context.system.shutdown()
      }
  }
}

// simulate retrieving data from a database or directory
class RetrieveData(routerName: String) extends Actor {
  val target = context.actorFor(routerName)
  def receive = LoggingReceive {
    case Retrieve(count) =>
      for (i <- 1 to count) {
        val name = "Joe" + self.path.name + i
        val email = "joe@joe.com"
        println("Retriever " + self.path.name +" retrieving data for " + name + " and passing to " + target.path)
        target ! new Build(name, email)
        Thread.sleep(200)
      }
  }
}

// simulate building the email to be sent to a particular address
class EmailBuilder(routerName: String) extends Actor {
  val target = context.actorFor(routerName)
  def receive = LoggingReceive {
    case Build(name, email) =>
      Thread.sleep(1000)
      println("Builder " + self.path.name +" building email for " + name + " and passing to " + target.path)
      target ! new Send(name, "Hello, sailor", email)
  }
}

// simulate sending the email
class SmtpSender(routerName: String) extends Actor {
  val target = context.actorFor(routerName)
  def receive = LoggingReceive {
    case Send(name, text, email) => {
      Thread.sleep(1000)
      println("Sender " + self.path.name +" sending email for " + name + " and passing to " + target.path)
      target ! new Update(name)
    }
  }
}

// simulate updating the database to say the email has been sent
class DatabaseUpdater(routerName: String) extends Actor {
  val target = context.actorFor(routerName)
  def receive = LoggingReceive {
    case Update(name) => {
      println("Updater " + self.path.name +" updating information for " + name + " and passing to " + target.path)
      Thread.sleep(1000)
      target ! Complete
    }
  }
}